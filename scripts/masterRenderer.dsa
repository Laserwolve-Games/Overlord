var oContentMgr = App.getContentMgr();
var oScriptArgs = JSON.parse(App.scriptArgs[0]);
var nTotalNumberOfInstances = oScriptArgs['num_instances'];
var sMasterTemplatePath = oScriptArgs['template_path'];
var oScriptFileInfo = new DzFileInfo(getScriptFileName());
var sScriptPath = oScriptFileInfo.path();
var nInstanceNumber = App.instanceName();
var sOutputDirectory = oScriptArgs['image_output_dir'];
var oOutputDirectory = new DzDir(sOutputDirectory);
var sSubjectFilepath = oScriptArgs['subject_file'];
var aAnimationFilepaths = oScriptArgs['animations'].toString().split(',');
var aPropAnimationFilepaths = oScriptArgs['prop_animations'].toString().split(',');
var aGearFilepaths = oScriptArgs['gear'].toString().split(',');
var aGearAnimationFilepaths = oScriptArgs['gear_animations'].toString().split(',');
var nDEGREES_IN_CIRCLE = 360;
var nRENDERS_PER_SESSION = oScriptArgs['renders_per_session'];
var nRenderCounter = 0;
var nFrameRate = oScriptArgs['frame_rate'];
var bRenderShadows = oScriptArgs['render_shadows'];
var nDAZ_TICKS = 4800;
var nTicksPerFrame = nDAZ_TICKS / nFrameRate;
var bOverwriteExistingImages = false;
var oRenderMgr;
var oIrayOptions;
var oRenderer;
var oEnvironmentOptionsPropertyGroups;
var oRenderOptions;
var oDrawGroundProperty;
var oEnvironmentModeProperty;
var oRoot;
var oShadowPlane;
var oSettings = new DzSettings();
var oHttpHelper = new DzHttpHelper();
var oHttp = new DzHttpHelper();

var sAddress = '127.0.0.1';
var sPort = 9090;
var sSecurity = 'http';
var sSecureProtocol = 'https';

oHttp.setConnectionMode(sSecurity);
oHttp.setHost(sAddress);
oHttp.setPort(sPort);
oHttp.setPath("/");
oHttp.setRequestMethod("GET");

oSettings.setIntValue('Connection', 0);
oSettings.setStringValue('Server', sAddress);
oSettings.setBoolValue('Secure', sSecurity == sSecureProtocol);
oSettings.setIntValue('Port', sPort);
oSettings.setStringValue('Username', 'admin');
oSettings.setStringValue('Password', 'admin');

// Obtain the desired name out of a filepath or filename.
function getName(sFileName) {
	return new DzFileInfo(sFileName).completeBaseName();
}

// The Overlord UI passes an array with a single, undefined object
// whenever filepath(s) are not specified.
function thereAre(aArray) {
	return aArray[0] !== '';
}

// Set the Matte Parameter of a subject and its children.
function setMatte(oSubject, bBool) {
	if (oSubject.matteParameter) oSubject.matteParameter.setValue(bBool);

	for (var nChildCounter = 0; nChildCounter != oSubject.children.length; nChildCounter++) {
		var oChild = oSubject.children[nChildCounter];
		oChild.matteParameter = oChild.findPropertyByLabel('Enable Iray Matte');
		if (oChild.matteParameter) oChild.matteParameter.setValue(bBool);
	}
}
function renderCore(sSubjectName, sAnimationName, bIsGear, bIsShadow) {

	oSubject.children = oSubject.getNodeChildren(true);
	oSubject.matteParameter = oSubject.findPropertyByLabel('Enable Iray Matte');

	// These variables have to be determined when we start rendering
	oRenderMgr = App.getRenderMgr();
	oIrayOptions = oRenderMgr.getRenderElementObjects()[1];
	oRenderer = oRenderMgr.findRenderer('DzIrayRenderer');
	oRenderer.setBridgeConfiguration(oSettings);
	oEnvironmentOptionsPropertyGroups = oRenderMgr.getRenderElementObjects()[3].getPropertyGroups();
	oRenderOptions = oRenderMgr.getRenderOptions();
	oDrawGroundProperty = oEnvironmentOptionsPropertyGroups.findProperty('Draw Ground');
	oEnvironmentModeProperty = oEnvironmentOptionsPropertyGroups.findProperty('Environment Mode');
	oRoot = Scene.findNodeByLabel('root');
	oRootYRotControl = oRoot.getYRotControl();
	oShadowPlane = Scene.findNodeByLabel('shadowPlane');
	var oCamera = Scene.findCameraByLabel('isometricCamera');

	// Read the subject's JSON to see how many angles it has
	{
		var oSubjectFile = new DzFile(sSubjectFilepath);
		var nAngles = 16;

		oSubjectFile.open(DzFile.ReadOnly);

		var nAnglesFromJson = JSON.parse(oSubjectFile.read()).asset_info.angles;

		oSubjectFile.close();

		if (nAnglesFromJson) nAngles = nAnglesFromJson;
		else App.warning('Number of angles not found in the JSON for ' + sSubjectFilepath +
			'. Using default of value of ' + nAngles + ' angles.');

		var nDegrees = nDEGREES_IN_CIRCLE / nAngles;
	}
	
	// Read the animation's JSON to see how many frames it has
	if (sAnimationName != 'static') {
		// https://github.com/Laserwolve-Games/Overlord/discussions/4
		var oAnimationFile = new DzFile(sAnimationFilepath);

		oAnimationFile.open(DzFile.ReadOnly);
		var oAnimationsJson = JSON.parse(oAnimationFile.read()).scene.animations;
		oAnimationFile.close();

		for (var nJsonCounter = 0; nJsonCounter < oAnimationsJson.length; nJsonCounter++) {
			var nNumberOfFrames = oAnimationsJson[nJsonCounter].keys.length;

			if (nNumberOfFrames > 1) {
				// Subtract 1 here to make it 0-based
				Scene.setAnimRange(DzTimeRange(0, (nNumberOfFrames - 1) * nTicksPerFrame));

				break;
			}
		}
	} else Scene.setAnimRange(DzTimeRange(0, 0));

	if (bIsGear) {
		// Add the gear to the canvas.
		oIrayOptions.addNodeToNodeList('visibleNodes', oGear);

		// Add all gear children to the canvas as well.
		for (var nGearChildrenCounter = 0; nGearChildrenCounter != aGearChildren.length; nGearChildrenCounter++)
			oIrayOptions.addNodeToNodeList('visibleNodes', aGearChildren[nGearChildrenCounter]);
	}

	// Add the subject as a child to the root
	oRoot.addNodeChild(oSubject, true);

	// variables that have to be determined when we start rendering
	var nFramesTotal = Scene.getPlayRange().end / nTicksPerFrame;

	// Loop through each angle...
	for (var nAngle = 0; nAngle != nDEGREES_IN_CIRCLE; nAngle = nAngle + nDegrees) {
		var nOutputAngle = 90 - nAngle;
		if (nOutputAngle <= -180) nOutputAngle += 360;

		// Loop through each frame...
		frameLoop: for (var nFrame = 0; nFrame <= nFramesTotal; nFrame++) {
			// Check if the current Daz instance should render this frame.
			if ((nFrame - (nInstanceNumber - 1)) % nTotalNumberOfInstances != 0) continue;

			var sFinalName = sSubjectName + (bIsShadow ? ' shadow_' : '_')
			+ sAnimationName + '_' + nOutputAngle + '_' + ('000' + nFrame).slice(-3);

			var sZipPath = sOutputDirectory + '/' + sSubjectName + (bIsShadow ? ' shadow' : '')
				+ '/' + sAnimationName + '/' + sAnimationName + '_' + nOutputAngle + '.zip';

			if(oOutputDirectory.exists(sZipPath)) {

					var sFinalNameWithExtension = sFinalName + '.png';
					var oZipFile = new DzZipFile(sZipPath);

					oZipFile.open(DzZipFile.ReadOnly);

					var aFileNames = oZipFile.getFileNames();

					oZipFile.close();

					for (var nFileNameCounter = 0; nFileNameCounter < aFileNames.length; nFileNameCounter++) {

						var sFileName = aFileNames[nFileNameCounter];

						if (sFileName === sFinalNameWithExtension) {

							App.log(sFinalNameWithExtension + ' already exists in zip. Skipping this frame.');

							continue frameLoop;
						}
					}
				}

			App.log('Setting frame to ' + nFrame);
			Scene.setFrame(nFrame);
			// Do this every frame, or else it will interpolate.
			App.log('Setting Y rotation to ' + nAngle);
			oRootYRotControl.setValue(nAngle);

			if (bIsShadow) {
				// Scene Only
				oEnvironmentModeProperty.setValue(3);
				oDrawGroundProperty.setValue(true);
				oShadowPlane.setVisible(true);
				oIrayOptions.renderToCanvases = false;
				if (bIsGear) setMatte(oSubject, true);
			} else {
				// Sun-Sky Only
				oEnvironmentModeProperty.setValue(2);
				oDrawGroundProperty.setValue(false);
				oShadowPlane.setVisible(false);
				setMatte(oSubject, false);
				if (bIsGear) oIrayOptions.renderToCanvases = true;
			}
			// Wait for everything else to finish first, specifically the mesh smoother
			while (backgroundProgressIsActive()) processEvents();

			App.log('Sending render to Iray Server...');
			
			var sHttpRequestError;

			do {

				// This returns a truthy byteArray regardless of the status
				// of the server, so we're not using it to check server status.
				oHttp.doSynchronousRequest();

				// This returns an empty string upon successful connection,
				// otherwise it returns the error as a string.
				sHttpRequestError = oHttp.getError();

				if (sHttpRequestError) {
					App.log('HTTP request error: ' + sHttpRequestError);
				}

			} while (sHttpRequestError);

			oRenderer.exportRenderToBridgeQueue(sFinalName, 'png', oCamera, oRenderOptions, 0);

			nRenderCounter++;

			if (nRenderCounter >= nRENDERS_PER_SESSION) {
				
				App.log('Render session limit reached. Exiting...');
				
				return;
			}
		}
		return;
	}
	if (bRenderShadows) {
		if (!bIsShadow) renderCore(sSubjectName, sAnimationName, bIsGear, true);
	}
}
function filterFilepathsBySuffix(aFilepaths, suffix) {
	var result = [];
	for (var i = 0; i < aFilepaths.length; i++) {
		if (aFilepaths[i].indexOf(suffix) === aFilepaths[i].length - suffix.length) {
			result.push(aFilepaths[i]);
		}
	}
	return result;
}

var sSubjectName = getName(sSubjectFilepath);

if (thereAre(aAnimationFilepaths)) {
	for (var nAnimationFilepathsCounter = 0; nAnimationFilepathsCounter != aAnimationFilepaths.length; nAnimationFilepathsCounter++) {
		var sAnimationFilepath = aAnimationFilepaths[nAnimationFilepathsCounter];
		var sAnimationName = getName(sAnimationFilepath);

		// Start with a blank scene
		oContentMgr.openFile(sMasterTemplatePath, false);

		// Merge in the subject
		oContentMgr.openFile(sSubjectFilepath, true);

		var oSubject = Scene.findNodeByLabel('subject');

		oContentMgr.openFile(sAnimationFilepath, true);

		if (thereAre(aPropAnimationFilepaths)) {
			for (var nPropAnimationCounter = 0; nPropAnimationCounter != aPropAnimationFilepaths.length; nPropAnimationCounter++) {
				
				var sPropAnimationFilepath = aPropAnimationFilepaths[nPropAnimationCounter];
				var sPropAnimationFileName = getName(sPropAnimationFilepath);
				var aPropAnimationProperties = sPropAnimationFileName.split('-');
				var sAnimationOfPropAnimation = aPropAnimationProperties.shift();
				var sPropOfPropAnimation = aPropAnimationProperties.pop();

				if (sAnimationName == sAnimationOfPropAnimation) {
					
					var oProp = Scene.findNodeByLabel(sPropOfPropAnimation);

					oSubject.select(false);
					oProp.select(true);

					oContentMgr.openFile(sPropAnimationFilepath, true);

					oProp.select(false);
					oSubject.select(true);
				} else continue;
			}
		}

		if (thereAre(aGearFilepaths)) {
			for (var nGearCounter = 0; nGearCounter != aGearFilepaths.length; nGearCounter++) {
				var sGearFilepath = aGearFilepaths[nGearCounter];

				oContentMgr.openFile(sGearFilepath, true);

				var sGearName = getName(sGearFilepath);
				var oGear = Scene.findNodeByLabel('gear');

				var aGearChildren = oGear.getNodeChildren(false);

				renderCore(sSubjectName + ' ' + sGearName, sAnimationName, true, false);

				Scene.removeNode(oGear);
			}
		} else renderCore(sSubjectName, sAnimationName, false, false);
	}
} else {
	oContentMgr.openFile(sMasterTemplatePath, false);

	oContentMgr.openFile(sSubjectFilepath, true);

	var oSubject = Scene.findNodeByLabel('subject');

	renderCore(sSubjectName, 'static', false, false);
}

// App.delayedExit();