// Constants
var DEGREES_IN_CIRCLE = 360;
var DAZ_TICKS = 4800;
var DEFAULT_ANGLES = 16;
var ENVIRONMENT_MODE_SUN_SKY = 2;
var ENVIRONMENT_MODE_SCENE_ONLY = 3;

// Initialize core variables
var oContentMgr = App.getContentMgr();
var oScriptArgs = JSON.parse(App.scriptArgs[0]);
var nTotalNumberOfInstances = oScriptArgs['num_instances'];
var sMasterTemplatePath = oScriptArgs['template_path'];
var oScriptFileInfo = new DzFileInfo(getScriptFileName());
var sScriptPath = oScriptFileInfo.path();
var nInstanceNumber = App.instanceName();
var sOutputDirectory = oScriptArgs['image_output_dir'];
var oOutputDirectory = new DzDir(sOutputDirectory);
var aFilepaths = oScriptArgs['source_files'].toString().split(',');
var nFrameRate = oScriptArgs['frame_rate'];
var bRenderShadows = oScriptArgs['render_shadows'];
var nTicksPerFrame = DAZ_TICKS / nFrameRate;
var bOverwriteExistingImages = false;
var oRenderMgr;
var oIrayOptions;
var oRenderer;
var oEnvironmentOptionsPropertyGroups;
var oRenderOptions;
var oDrawGroundProperty;
var oEnvironmentModeProperty;
var oRoot;
var oShadowPlane;
var oSettings = new DzSettings();

oSettings.setIntValue('Connection', 0);
oSettings.setStringValue('Server', '127.0.0.1');
oSettings.setBoolValue('Secure', false);
oSettings.setIntValue('Port', 9090);
oSettings.setStringValue('Username', 'admin');
oSettings.setStringValue('Password', 'admin');

// Helper Functions
// Safe file operations with error handling
function safeOpenFile(sFilePath, bMerge) {
	var oFileInfo = new DzFileInfo(sFilePath);
	if (!oFileInfo.exists()) {
		App.warning('File does not exist: ' + sFilePath);
		return false;
	}
	
	try {
		return oContentMgr.openFile(sFilePath, bMerge);
	} catch (e) {
		App.warning('Failed to open file: ' + sFilePath + ' - Error: ' + e.toString());
		return false;
	}
}

// Safe node finding with error handling
function findNodeSafely(sNodeName) {
	var oNode = Scene.findNodeByLabel(sNodeName);
	if (!oNode) {
		App.warning('Node not found: ' + sNodeName);
	}
	return oNode;
}

// Safe JSON parsing with error handling
function parseJsonSafely(oFile) {
	try {
		var sContent = oFile.read();
		if (!sContent || sContent.length === 0) {
			App.warning('File is empty or could not be read');
			return null;
		}
		return JSON.parse(sContent);
	} catch (e) {
		App.warning('Failed to parse JSON: ' + e.toString());
		return null;
	}
}

// Safe file reading with error handling
function readJsonFromFile(sFilePath) {
	var oFileInfo = new DzFileInfo(sFilePath);
	if (!oFileInfo.exists()) {
		App.warning('JSON file does not exist: ' + sFilePath);
		return null;
	}
	
	var oFile = new DzFile(sFilePath);
	if (!oFile.open(DzFile.ReadOnly)) {
		App.warning('Failed to open JSON file: ' + sFilePath);
		return null;
	}
	
	var oJsonData = parseJsonSafely(oFile);
	oFile.close();
	return oJsonData;
}

// Obtain the desired name out of a filepath or filename.
function getName(sFileName) {
	if (!sFileName) {
		App.warning('getName called with empty filename');
		return '';
	}
	return sFileName.split('/').pop().split('_')[0];
}

// Set the Matte Parameter of a subject and its children.
function setMatte(oSubject, bBool) {
	if (!oSubject) {
		App.warning('setMatte called with null subject');
		return;
	}
	
	if (oSubject.matteParameter) {
		oSubject.matteParameter.setValue(bBool);
	}

	var aChildren = oSubject.getNodeChildren(true);
	for (var nChildCounter = 0; nChildCounter < aChildren.length; nChildCounter++) {
		var oChild = aChildren[nChildCounter];
		if (oChild) {
			var oMatteParameter = oChild.findPropertyByLabel('Enable Iray Matte');
			if (oMatteParameter) {
				oMatteParameter.setValue(bBool);
			}
		}
	}
}
function renderCore(sSubjectName, sAnimationName, bIsGear, bIsShadow, oSubject, sSubjectFilepath, sAnimationFilepath, oGear, aGearChildren) {
	// Validate required parameters
	if (!oSubject) {
		App.warning('renderCore: oSubject is null');
		return;
	}
	
	if (!sSubjectFilepath) {
		App.warning('renderCore: sSubjectFilepath is null');
		return;
	}

	// Initialize subject properties
	var aSubjectChildren = oSubject.getNodeChildren(true);
	var oMatteParameter = oSubject.findPropertyByLabel('Enable Iray Matte');

	// These variables have to be determined when we start rendering
	oRenderMgr = App.getRenderMgr();
	if (!oRenderMgr) {
		App.warning('Failed to get render manager');
		return;
	}
	
	var aRenderElements = oRenderMgr.getRenderElementObjects();
	if (aRenderElements.length < 4) {
		App.warning('Insufficient render elements available');
		return;
	}
	
	oIrayOptions = aRenderElements[1];
	oRenderer = oRenderMgr.findRenderer('DzIrayRenderer');
	if (!oRenderer) {
		App.warning('DzIrayRenderer not found');
		return;
	}
	
	oRenderer.setBridgeConfiguration(oSettings);
	oEnvironmentOptionsPropertyGroups = aRenderElements[3].getPropertyGroups();
	oRenderOptions = oRenderMgr.getRenderOptions();
	oDrawGroundProperty = oEnvironmentOptionsPropertyGroups.findProperty('Draw Ground');
	oEnvironmentModeProperty = oEnvironmentOptionsPropertyGroups.findProperty('Environment Mode');
	oRoot = findNodeSafely('root');
	oShadowPlane = findNodeSafely('shadowPlane');
	var oCamera = Scene.findCameraByLabel('isometricCamera');
	
	if (!oCamera) {
		App.warning('isometricCamera not found');
		return;
	}

	// Read the subject's JSON to see how many angles it has
	var nAngles = DEFAULT_ANGLES;
	var oSubjectJsonData = readJsonFromFile(sSubjectFilepath);
	
	if (oSubjectJsonData && oSubjectJsonData.asset_info && oSubjectJsonData.asset_info.angles) {
		nAngles = oSubjectJsonData.asset_info.angles;
		App.log('Using ' + nAngles + ' angles from subject JSON');
	} else {
		App.warning('Number of angles not found in the JSON for ' + sSubjectFilepath +
			'. Using default value of ' + nAngles + ' angles.');
	}
	
	var nDegrees = DEGREES_IN_CIRCLE / nAngles;
	
	// Read the animation's JSON to see how many frames it has
	if (sAnimationName != 'static' && sAnimationFilepath) {
		App.log('Processing animation: ' + sAnimationName);
		var oAnimationJsonData = readJsonFromFile(sAnimationFilepath);
		
		if (oAnimationJsonData && oAnimationJsonData.scene && oAnimationJsonData.scene.animations) {
			var oAnimationsJson = oAnimationJsonData.scene.animations;
			
			for (var i = 0; i < oAnimationsJson.length; i++) {
				if (oAnimationsJson[i].keys && oAnimationsJson[i].keys.length > 1) {
					var nNumberOfFrames = oAnimationsJson[i].keys.length;
					// Subtract 1 here to make it 0-based
					Scene.setAnimRange(DzTimeRange(0, (nNumberOfFrames - 1) * nTicksPerFrame));
					App.log('Set animation range to ' + nNumberOfFrames + ' frames');
					break;
				}
			}
		} else {
			App.warning('Failed to read animation data from: ' + sAnimationFilepath);
		}
	} else {
		Scene.setAnimRange(DzTimeRange(0, 0));
		App.log('Set static animation range');
	}

	if (bIsGear && oGear) {
		// Add the gear to the canvas.
		oIrayOptions.addNodeToNodeList('visibleNodes', oGear);

		// Add all gear children to the canvas as well.
		if (aGearChildren && aGearChildren.length > 0) {
			for (var nGearChildrenCounter = 0; nGearChildrenCounter < aGearChildren.length; nGearChildrenCounter++) {
				if (aGearChildren[nGearChildrenCounter]) {
					oIrayOptions.addNodeToNodeList('visibleNodes', aGearChildren[nGearChildrenCounter]);
				}
			}
		}
	}

	// Add the subject as a child to the root
	if (oRoot) {
		oRoot.addNodeChild(oSubject, true);
	} else {
		App.warning('Root node not found, cannot add subject');
		return;
	}

	// variables that have to be determined when we start rendering
	var nFramesTotal = Scene.getPlayRange().end / nTicksPerFrame;
	App.log('Total frames to render: ' + nFramesTotal);

	// Loop through each angle...
	for (var nAngle = 0; nAngle < DEGREES_IN_CIRCLE; nAngle += nDegrees) {
		var nOutputAngle = 90 - nAngle;
		if (nOutputAngle <= -180) nOutputAngle += 360;

		// Loop through each frame...
		for (var nFrame = 0; nFrame <= nFramesTotal; nFrame++) {
			// Check if the current Daz instance should render this frame.
			if ((nFrame - (nInstanceNumber - 1)) % nTotalNumberOfInstances != 0) continue;

			var sFinalName = sSubjectName + '_' + sAnimationName
				+ (bIsShadow ? '_shadow_' : '_') + nOutputAngle + '_' + ('000' + nFrame).slice(-3);

			var sFinalFullPath = sOutputDirectory + '/' + sFinalName + '.png';

			if (oOutputDirectory.exists(sFinalFullPath)) {
				// Skip images that already exist
				App.log(sFinalFullPath + ' already exists. Skipping render.');
				continue;
			} else {
				App.log('Rendering: ' + sFinalFullPath);
			}

			Scene.setFrame(nFrame);
			// Do this every frame, or else it will interpolate.
			if (oRoot && oRoot.getYRotControl()) {
				oRoot.getYRotControl().setValue(nAngle);
			}

			if (bIsShadow) {
				// Scene Only
				if (oEnvironmentModeProperty) oEnvironmentModeProperty.setValue(ENVIRONMENT_MODE_SCENE_ONLY);
				if (oDrawGroundProperty) oDrawGroundProperty.setValue(true);
				if (oShadowPlane) oShadowPlane.setVisible(true);
				oIrayOptions.renderToCanvases = false;
				if (bIsGear) setMatte(oSubject, true);
			} else {
				// Sun-Sky Only
				if (oEnvironmentModeProperty) oEnvironmentModeProperty.setValue(ENVIRONMENT_MODE_SUN_SKY);
				if (oDrawGroundProperty) oDrawGroundProperty.setValue(false);
				if (oShadowPlane) oShadowPlane.setVisible(false);
				setMatte(oSubject, false);
				if (bIsGear) oIrayOptions.renderToCanvases = true;
			}
			
			// Wait for everything else to finish first, specifically the mesh smoother
			while (backgroundProgressIsActive()) {
				processEvents();
			}

			App.log('Sending render to Iray Server...');
			try {
				oRenderer.exportRenderToBridgeQueue(sFinalName, 'png', oCamera, oRenderOptions, 0);
			} catch (e) {
				App.warning('Failed to export render: ' + e.toString());
			}
		}
	}
	
	// Handle shadow rendering recursively if needed
	if (bRenderShadows && !bIsShadow) {
		App.log('Starting shadow rendering pass...');
		renderCore(sSubjectName, sAnimationName, bIsGear, true, oSubject, sSubjectFilepath, sAnimationFilepath, oGear, aGearChildren);
	}
}
function filterFilepathsBySuffix(aFilepaths, sSuffix) {
	if (!aFilepaths || !sSuffix) {
		App.warning('filterFilepathsBySuffix called with invalid parameters');
		return [];
	}
	
	var aResult = [];
	for (var i = 0; i < aFilepaths.length; i++) {
		var sFilepath = aFilepaths[i];
		if (sFilepath && sFilepath.indexOf(sSuffix) === sFilepath.length - sSuffix.length) {
			aResult.push(sFilepath);
		}
	}
	return aResult;
}

// There will only be one subject file
var sSubjectFilepath = filterFilepathsBySuffix(aFilepaths, '_subject.duf')[0];
var aAnimationFilepaths = filterFilepathsBySuffix(aFilepaths, '_animation.duf');
var aPropAnimationFilepaths = filterFilepathsBySuffix(aFilepaths, '_propAnimation.duf');
var aGearFilepaths = filterFilepathsBySuffix(aFilepaths, '_gear.duf');
var aGearAnimationFilepaths = filterFilepathsBySuffix(aFilepaths, '_gearAnimation.duf');

if (!sSubjectFilepath) {
	App.warning('No subject file found in provided filepaths');
	if (bCloseDazOnFinish) App.delayedExit();
	return;
}

var sSubjectName = getName(sSubjectFilepath);
App.log('Processing subject: ' + sSubjectName);

// If there are animations, loop over them
if (aAnimationFilepaths.length) {
	App.log('Found ' + aAnimationFilepaths.length + ' animation(s) to process');
	
	for (var nAnimationFilepathsCounter = 0; nAnimationFilepathsCounter < aAnimationFilepaths.length; nAnimationFilepathsCounter++) {
		var sAnimationFilepath = aAnimationFilepaths[nAnimationFilepathsCounter];
		var sAnimationName = getName(sAnimationFilepath);
		App.log('Processing animation: ' + sAnimationName);

		// Start with a blank scene
		if (!safeOpenFile(sMasterTemplatePath, false)) {
			App.warning('Failed to open master template: ' + sMasterTemplatePath);
			continue;
		}

		// Merge in the subject
		if (!safeOpenFile(sSubjectFilepath, true)) {
			App.warning('Failed to open subject file: ' + sSubjectFilepath);
			continue;
		}

		var oSubject = findNodeSafely('subject');
		if (!oSubject) {
			App.warning('Subject node not found after loading subject file');
			continue;
		}

		if (!safeOpenFile(sAnimationFilepath, true)) {
			App.warning('Failed to open animation file: ' + sAnimationFilepath);
			continue;
		}

		// If this animation has corresponding animated props, merge them all in
		if (aPropAnimationFilepaths.length) {
			App.log('Processing ' + aPropAnimationFilepaths.length + ' prop animation(s)');
			
			for (var nPropAnimationCounter = 0; nPropAnimationCounter < aPropAnimationFilepaths.length; nPropAnimationCounter++) {
				var sPropAnimationFilepath = aPropAnimationFilepaths[nPropAnimationCounter];
				var sPropAnimationFileName = getName(sPropAnimationFilepath);
				var sCurrentAnimationName = getName(sAnimationFilepath);

				if (sPropAnimationFileName.indexOf(sCurrentAnimationName) !== -1) {
					var sNameOfPropToAnimate = sPropAnimationFileName.split('-').pop();
					var oProp = findNodeSafely(sNameOfPropToAnimate);

					if (oProp) {
						oSubject.select(false);
						oProp.select(true);

						if (safeOpenFile(sPropAnimationFilepath, true)) {
							App.log('Applied prop animation: ' + sPropAnimationFileName);
						} else {
							App.warning('Failed to load prop animation: ' + sPropAnimationFilepath);
						}

						oProp.select(false);
						oSubject.select(true);
					} else {
						App.warning('Prop not found for animation: ' + sNameOfPropToAnimate);
					}
				}
			}
		}

		if (aGearFilepaths.length) {
			App.log('Processing ' + aGearFilepaths.length + ' gear file(s)');
			
			for (var nGearCounter = 0; nGearCounter < aGearFilepaths.length; nGearCounter++) {
				var sGearFilepath = aGearFilepaths[nGearCounter];

				if (!safeOpenFile(sGearFilepath, true)) {
					App.warning('Failed to open gear file: ' + sGearFilepath);
					continue;
				}

				var sGearName = getName(sGearFilepath);
				var oGear = findNodeSafely('gear');
				
				if (!oGear) {
					App.warning('Gear node not found after loading gear file: ' + sGearFilepath);
					continue;
				}

				var aGearChildren = oGear.getNodeChildren(false);
				App.log('Rendering subject with gear: ' + sGearName);

				renderCore(sSubjectName + '_' + sGearName, sAnimationName, true, false, oSubject, sSubjectFilepath, sAnimationFilepath, oGear, aGearChildren);

				Scene.removeNode(oGear);
			}
		} else {
			App.log('No gear files found, rendering subject only');
			renderCore(sSubjectName, sAnimationName, false, false, oSubject, sSubjectFilepath, sAnimationFilepath, null, null);
		}
	}
} else {
	App.log('No animations found, processing static subject');
	
	if (!safeOpenFile(sMasterTemplatePath, false)) {
		App.warning('Failed to open master template: ' + sMasterTemplatePath);
		if (bCloseDazOnFinish) App.delayedExit();
		return;
	}

	if (!safeOpenFile(sSubjectFilepath, true)) {
		App.warning('Failed to open subject file: ' + sSubjectFilepath);
		if (bCloseDazOnFinish) App.delayedExit();
		return;
	}

	var oSubject = findNodeSafely('subject');
	if (!oSubject) {
		App.warning('Subject node not found after loading subject file');
		if (bCloseDazOnFinish) App.delayedExit();
		return;
	}

	renderCore(sSubjectName, 'static', false, false, oSubject, sSubjectFilepath, null, null, null);
}

App.log('Rendering process completed');